import unittest
import re
import sys
import os
import json
import filecmp

sys.path.append(os.path.abspath(os.path.dirname(__file__) + '/../app/vfg/' + "parser"))
sys.path.append(os.path.abspath(os.path.dirname(__file__) + '/../app/vfg/' + "solver"))
sys.path.append(os.path.abspath(os.path.dirname(__file__) + '/../app/vfg/' + "adapter/visualiser_adapter"))
import Parser_Functions, Animation_parser, Domain_parser, Plan_generator, Initialise, Solver
from Problem_parser import *
from Predicates_generator import *

import Solver, Initialise
import Transfer

class TestStringMethods(unittest.TestCase):

    # Initial test case
    def test_upper(self):
        self.assertEqual('foo'.upper(), 'FOO')

    # Initial test case
    def test_isupper(self):
        self.assertTrue('FOO'.isupper())
        self.assertFalse('Foo'.isupper())

    # Initial test case
    def test_split(self):
        s = 'hello world'
        self.assertEqual(s.split(), ['hello', 'world'])
        with self.assertRaises(TypeError):
            s.split(2)

    def test_planimation_process(self):
        """ Test case for testing the whole process of planimation
        Involves reading PDDL files; Getting the plan of the problem;
        Parsing the domain and animation files; Generate the animation file.

        Expected Input:
            domain.pddl, problem.pddl, domain_ap.pddl: The PDDL files.
            expected_output.vfg: The vfg file used to compare with the output.

        Expected Output:
            test.vfg: The vfg file generated in the process.
        """

        url_link = ''

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain_ap.pddl'), 'r', encoding='utf-8-sig') as f:
            animation_content = f.read()

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain.pddl'), 'r', encoding='utf-8-sig') as f:
            domain_content = f.read().lower()
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'problem.pddl'), 'r', encoding='utf-8-sig') as f:
            problem_content = f.read().lower()

        plan = Plan_generator.get_plan(domain_content, problem_content, url_link)

        predicates_list = Domain_parser.get_domain_json(domain_content)
        problem_dic = get_problem_dic(problem_content, predicates_list)
        object_list = get_object_list(problem_content)

        animation_profile = json.loads(Animation_parser.get_animation_profile(animation_content, object_list))

        stages = get_stages(plan, problem_dic, problem_content, predicates_list)

        result = Solver.get_visualisation_dic(stages, animation_profile, plan['result']['plan'], problem_dic)
        objects_dic = Initialise.initialise_objects(stages["objects"], animation_profile)
        final = Transfer.generate_visualisation_file(result, list(objects_dic.keys()), animation_profile, plan['result']['plan'])

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "test.vfg"), "w") as f:
            json.dump(final, f)

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "test.vfg"), 'r', encoding='utf-8-sig') as f:
            output_content = f.read()

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "expect_output.vfg"), 'r', encoding='utf-8-sig') as f:
            expected_content = f.read()

        # Check that the generated vfg file is the same as the expected output
        self.assertTrue(filecmp.cmp(os.path.abspath(os.path.dirname(__file__) + '/test_files/' + 'test.vfg')
            , os.path.abspath(os.path.dirname(__file__) + '/test_files/' + 'expect_output.vfg'), shallow=False)
            , msg="The generated vfg file is different from the expected output.")

    def test_domain_parser(self):
        """ Test case for testing the domain parser functions
        Test the functionality of translate domain PDDL file into JSON structure.

        Expected Input:
            domain.pddl, 4_ops_domain.pddl: The domain PDDL files.

        Expected Output:
            simple_predicates_list(JSON): The JSON structure generated by the Domain_parser.
            complex_predicates_list(JSON): The JSON structure generated by the Domain_parser.
        """

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain.pddl'), 'r', encoding='utf-8-sig') as f:
            simple_domain_content = f.read().lower()

        simple_predicates_list = Domain_parser.get_domain_json(simple_domain_content)
        # simple domain predicates:
        # (:predicates
        # (connected ?x ?y - place)
	    # (at-robot ?x - place)
	    # (visited ?x - place))
        simple_expected_predicates = {'connected': 2, 'at-robot': 1, 'visited': 1}

        # Check that the generated simple predicates list is the same as the expected list
        self.assertTrue(simple_predicates_list == simple_expected_predicates
            , msg="The generated simple predicates list is different from the expected list")

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + '4_ops_domain.pddl'), 'r', encoding='utf-8-sig') as f:
            complex_domain_content = f.read().lower()

        complex_predicates_list = Domain_parser.get_domain_json(complex_domain_content)
        # (:predicates
        # (on ?x ?y)
        # (ontable ?x)
        # (clear ?x)
        # (handempty)
        # (holding ?x))
        complex_expected_predicates = {'on': 2, 'ontable': 1, 'clear': 1, 'handempty': 0, 'holding': 1}

        # Check that the generated complex predicates list is the same as the expected list
        self.assertTrue(complex_predicates_list == complex_expected_predicates
                        , msg="The generated complex predicates list is different from the expected list")

    def test_problem_parser(self):
        """ Test case for testing the problem parser functions
        Test the functionality of translate problem into JSON structure and dict structure

        Expected Input:
            domain.pddl, problem.pddl: The domain and problem PDDL files.
            4_ops_problem, 4_ops_domain.pddl: The domain and problem PDDL files.
            complex_expected_problem.json: The expecetd output JSON file.

        Expected Output:
            simple_problem_list(JSON): The JSON structure generated by the Problem_parser.
            complex_problem_list(JSON): The JSON structure generated by the Problem_parser.
        """

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + '4_ops_problem.pddl'), 'r', encoding='utf-8-sig') as f:
            simple_problem_content = f.read().lower()

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + '4_ops_domain.pddl'), 'r', encoding='utf-8-sig') as f:
            simple_domain_content = f.read().lower()

        simple_predicates_list = Domain_parser.get_domain_json(simple_domain_content)
        simple_problem_list = get_problem_dic(simple_problem_content, simple_predicates_list)

        simple_expected_problem = [
            {'init': [
                {'name': 'on', 'objectNames': ['a', 'c']},
                {'name': 'ontable', 'objectNames': ['b']},
                {'name': 'ontable', 'objectNames': ['c']},
                {'name': 'clear', 'objectNames': ['a']},
                {'name': 'clear', 'objectNames': ['b']},
                {'name': 'handempty', 'objectNames': ['No objects']}]},
            {'goal': [
                {'name': 'on', 'objectNames': ['a', 'b']},
                {'name': 'on', 'objectNames': ['b', 'c']}],
            'goal-condition': ['and']}]

        # Check that the generated simple problem list is the same as the expected output
        self.assertTrue(simple_problem_list == simple_expected_problem
            , msg="The generated simple problem list is different from the expected output")

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'problem.pddl'), 'r', encoding='utf-8-sig') as f:
            complex_problem_content = f.read().lower()
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain.pddl'), 'r', encoding='utf-8-sig') as f:
            complex_domain_content = f.read().lower()
        
        complex_predicates_list = Domain_parser.get_domain_json(complex_domain_content)
        complex_problem_list = get_problem_dic(complex_problem_content, complex_predicates_list)

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "complex_expected_problem.json"), "r") as f:
            complex_expected_problem = json.load(f)

        # Check that the generated complex problem list is the same as the expected output
        self.assertTrue(complex_expected_problem == complex_problem_list
            , msg="The generated complex problem list is different from the expected output")

    def test_predicates_generator(self):
        """ Test case for testing the predicates generator function
        Test the functionality of parse the predicates into the stage data structure

        Expected Input:
            domain.pddl, problem.pddl: The complex domain and problem PDDL files.
            complex_plan.json: The complex plan file.
            4_ops_problem, 4_ops_domain.pddl: The simple domain and problem PDDL files.
            simple_plan.json: The simple plan file.
            simple_expected_stages.json: The expected output JSON file.

        Expected Output:
            simple_stages(stage): The stage structure generated by the Predicates_parser.
            complex_stages(stage): The stage structure generated by the Predicates_parser.
        """

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + '4_ops_domain.pddl'), 'r', encoding='utf-8-sig') as f:
            simple_domain_content = f.read().lower()

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + '4_ops_problem.pddl'), 'r', encoding='utf-8-sig') as f:
            simple_problem_content = f.read().lower()

        with open(os.path.abspath(os.path.dirname(__file__)
                                  + '/test_files/' + 'simple_plan.json'), 'r', encoding='utf-8-sig') as f:
            simple_plan = json.load(f)

        simple_predicates_list = Domain_parser.get_domain_json(simple_domain_content)
        simple_problem_dic = get_problem_dic(simple_problem_content, simple_predicates_list)
        simple_object_list = get_object_list(simple_problem_content)
        simple_stages = get_stages(simple_plan, simple_problem_dic, simple_problem_content, simple_predicates_list)
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "simple_expected_stages.json"), "r") as f:
            simple_expected_stages = json.load(f)
        
        # Check that the generated simple stages are the same as the expected output
        self.assertTrue(simple_stages == simple_expected_stages
            , msg="The generated simple stages are different from the expected output")

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain.pddl'), 'r', encoding='utf-8-sig') as f:
            complex_domain_content = f.read().lower()
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'problem.pddl'), 'r', encoding='utf-8-sig') as f:
            complex_problem_content = f.read().lower()

        with open(os.path.abspath(os.path.dirname(__file__)
                                  + '/test_files/' + 'complex_plan.json'), 'r', encoding='utf-8-sig') as f:
            complex_plan = json.load(f)

        complex_predicates_list = Domain_parser.get_domain_json(complex_domain_content)
        complex_problem_dic = get_problem_dic(complex_problem_content, complex_predicates_list)
        complex_object_list = get_object_list(complex_problem_content)
        complex_stages = get_stages(complex_plan, complex_problem_dic, complex_problem_content, complex_predicates_list)
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "complex_expected_stages.json"), "r") as f:
            complex_expected_stages = json.load(f)

        # Check that the generated complex stages are the same as the expected output
        self.assertTrue(complex_stages == complex_expected_stages
            , msg="The generated complex stages are different from the expected output")

    def test_solver(self):
        """ Test case for testing the solver functions
        
        Expected Input:
            domain_ap.pddl, problem.pddl: The animation and problem PDDL files.
            expected_initialised_obj_dict.json: The expected output JSON file.

        Expected Output:
            initialised_obj_dict(dict): The dict structure generated by the solver functions.
            expected_obj_name_prop(object): The object generated by the solver functions.
        """

        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'domain_ap.pddl'), 'r', encoding='utf-8-sig') as f:
            animation_content = f.read()
    
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + 'problem.pddl'), 'r', encoding='utf-8-sig') as f:
            problem_content = f.read().lower()

        object_list = get_object_list(problem_content)
        animation_profile = json.loads(Animation_parser.get_animation_profile(animation_content, object_list))
        initialised_obj_dict = Initialise.initialise_objects(object_list, animation_profile)
        
        with open(os.path.abspath(os.path.dirname(__file__) 
            + '/test_files/' + "expected_initialised_obj_dict.json"), "r") as f:
            expected_initialised_obj_dict = json.load(f)
        
        # Check that the generated object dict is the same as the expected output
        self.assertTrue(initialised_obj_dict == expected_initialised_obj_dict
            , msg="The generated object dict is different from the expected output")

        # testing check rule
        true_predicate = {'name': 'at-robot', 'objectNames': ['loc1_1']}
        false_predicate = {'name': 'at-robot', 'objectNames': ['loc1_2']}
        objects_dic = {
            'loc1_1': {'prefabimage': 'img-square', 'showname': False, 'x': 100, 'y': 100, 'color': {'r': 0.0, 'g': 0.0, 'b': 1.0, 'a': 1.0}, 'width': 80, 'height': 80, 'depth': 1, 'name': 'loc1_1'},
            'loc1_2': {'prefabimage': 'img-square', 'showname': False, 'x': 100, 'y': False, 'color': {'r': 0.0, 'g': 0.0, 'b': 1.0, 'a': 1.0}, 'width': 80, 'height': 80, 'depth': 1, 'name': 'loc1_2'},
            'robot': {'prefabimage': 'img-robot', 'showname': False, 'x': 100, 'y': 100, 'color': {'r': 0.9804, 'g': 0.6353, 'b': 0.7098, 'a': 1.0}, 'width': 40, 'height': 40, 'depth': 2, 'name': 'robot'}}
        predicates_rules = {'at-robot':
                                {'rules': ['rule1', 'rule2', 'rule3'],
                                 'rule1': {'left': {'robot': ['x']},'value': {'equal': {'?x': 'x'}}},
                                 'rule2': {'left': {'robot': ['y']}, 'value': {'equal': {'?x': 'y'}}},
                                 'rule3': {'left': {'?x': ['color']}, 'value': {'equal': {'r': 0.9804, 'g': 0.6353, 'b': 0.7098, 'a': 1.0}}},
                                 'require': {'?x': ['x', 'y']},
                                 'objects': ['?x'],
                                 'custom_obj': ['robot']}}

        # Check that the solver working with the expected predicate, objects dict and predicates rules
        self.assertTrue(Solver.check_rule_complete(true_predicate, objects_dic, predicates_rules)
            , msg="The input predicate list, objects dict and predicates rules didn't match the expected input params for the solver")
        self.assertFalse(Solver.check_rule_complete(false_predicate, objects_dic, predicates_rules)
            , msg="The input params to the solver are fake data, but they match the expected input for the solver")

        # test get obj name
        property_dic = {'?x': ['property1', 'property2']}
        obj_ref_dic = {'?x': 'obj1'}
        expected_obj_name_prop = ('?x', 'obj1', ['property1', 'property2'])
        obj_name_prop = Solver.get_objname_property(property_dic, obj_ref_dic)

        # Check that the generated object is the same as the expected output
        self.assertTrue(expected_obj_name_prop == obj_name_prop
            , msg="The generated object is different from the expected output")


if __name__ == '__main__':
    unittest.main()
